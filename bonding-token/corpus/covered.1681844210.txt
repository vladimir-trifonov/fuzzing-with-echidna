/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/erc1363-payable-token/contracts/token/ERC1363/ERC1363.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import "../../../../openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
   6 |     | import "../../../../openzeppelin-contracts/contracts/utils/Address.sol";
   7 |     | import "../../../../openzeppelin-contracts/contracts/utils/introspection/ERC165.sol";
   8 |     | 
   9 |     | import "./IERC1363.sol";
  10 |     | import "./IERC1363Receiver.sol";
  11 |     | import "./IERC1363Spender.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title ERC1363
  15 |     |  * @dev Implementation of an ERC1363 interface.
  16 |     |  */
  17 |     | abstract contract ERC1363 is ERC20, IERC1363, ERC165 {
  18 |     |     using Address for address;
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev See {IERC165-supportsInterface}.
  22 |     |      */
  23 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
  24 |     |         return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId);
  25 |     |     }
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Transfer tokens to a specified address and then execute a callback on `to`.
  29 |     |      * @param to The address to transfer to.
  30 |     |      * @param amount The amount to be transferred.
  31 |     |      * @return A boolean that indicates if the operation was successful.
  32 |     |      */
  33 |     |     function transferAndCall(address to, uint256 amount) public virtual override returns (bool) {
  34 |     |         return transferAndCall(to, amount, "");
  35 |     |     }
  36 |     | 
  37 |     |     /**
  38 |     |      * @dev Transfer tokens to a specified address and then execute a callback on `to`.
  39 |     |      * @param to The address to transfer to
  40 |     |      * @param amount The amount to be transferred
  41 |     |      * @param data Additional data with no specified format
  42 |     |      * @return A boolean that indicates if the operation was successful.
  43 |     |      */
  44 |     |     function transferAndCall(address to, uint256 amount, bytes memory data) public virtual override returns (bool) {
  45 |     |         transfer(to, amount);
  46 |     |         require(_checkOnTransferReceived(_msgSender(), to, amount, data), "ERC1363: receiver returned wrong data");
  47 |     |         return true;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @dev Transfer tokens from one address to another and then execute a callback on `to`.
  52 |     |      * @param from The address which you want to send tokens from
  53 |     |      * @param to The address which you want to transfer to
  54 |     |      * @param amount The amount of tokens to be transferred
  55 |     |      * @return A boolean that indicates if the operation was successful.
  56 |     |      */
  57 |     |     function transferFromAndCall(address from, address to, uint256 amount) public virtual override returns (bool) {
  58 |     |         return transferFromAndCall(from, to, amount, "");
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Transfer tokens from one address to another and then execute a callback on `to`.
  63 |     |      * @param from The address which you want to send tokens from
  64 |     |      * @param to The address which you want to transfer to
  65 |     |      * @param amount The amount of tokens to be transferred
  66 |     |      * @param data Additional data with no specified format
  67 |     |      * @return A boolean that indicates if the operation was successful.
  68 |     |      */
  69 |     |     function transferFromAndCall(
  70 |     |         address from,
  71 |     |         address to,
  72 |     |         uint256 amount,
  73 |     |         bytes memory data
  74 |     |     ) public virtual override returns (bool) {
  75 |     |         transferFrom(from, to, amount);
  76 |     |         require(_checkOnTransferReceived(from, to, amount, data), "ERC1363: receiver returned wrong data");
  77 |     |         return true;
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
  82 |     |      * @param spender The address allowed to transfer to
  83 |     |      * @param amount The amount allowed to be transferred
  84 |     |      * @return A boolean that indicates if the operation was successful.
  85 |     |      */
  86 |     |     function approveAndCall(address spender, uint256 amount) public virtual override returns (bool) {
  87 |     |         return approveAndCall(spender, amount, "");
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
  92 |     |      * @param spender The address allowed to transfer to.
  93 |     |      * @param amount The amount allowed to be transferred.
  94 |     |      * @param data Additional data with no specified format.
  95 |     |      * @return A boolean that indicates if the operation was successful.
  96 |     |      */
  97 |     |     function approveAndCall(address spender, uint256 amount, bytes memory data) public virtual override returns (bool) {
  98 |     |         approve(spender, amount);
  99 |     |         require(_checkOnApprovalReceived(spender, amount, data), "ERC1363: spender returned wrong data");
 100 |     |         return true;
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev Internal function to invoke {IERC1363Receiver-onTransferReceived} on a target address.
 105 |     |      *  The call is not executed if the target address is not a contract.
 106 |     |      * @param sender address Representing the previous owner of the given token amount
 107 |     |      * @param recipient address Target address that will receive the tokens
 108 |     |      * @param amount uint256 The amount mount of tokens to be transferred
 109 |     |      * @param data bytes Optional data to send along with the call
 110 |     |      * @return whether the call correctly returned the expected magic value
 111 |     |      */
 112 |     |     function _checkOnTransferReceived(
 113 |     |         address sender,
 114 |     |         address recipient,
 115 |     |         uint256 amount,
 116 |     |         bytes memory data
 117 |     |     ) internal virtual returns (bool) {
 118 |     |         if (!recipient.isContract()) {
 119 |     |             revert("ERC1363: transfer to non contract address");
 120 |     |         }
 121 |     | 
 122 |     |         try IERC1363Receiver(recipient).onTransferReceived(_msgSender(), sender, amount, data) returns (bytes4 retval) {
 123 |     |             return retval == IERC1363Receiver.onTransferReceived.selector;
 124 |     |         } catch (bytes memory reason) {
 125 |     |             if (reason.length == 0) {
 126 |     |                 revert("ERC1363: transfer to non ERC1363Receiver implementer");
 127 |     |             } else {
 128 |     |                 /// @solidity memory-safe-assembly
 129 |     |                 assembly {
 130 |     |                     revert(add(32, reason), mload(reason))
 131 |     |                 }
 132 |     |             }
 133 |     |         }
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @dev Internal function to invoke {IERC1363Receiver-onApprovalReceived} on a target address.
 138 |     |      *  The call is not executed if the target address is not a contract.
 139 |     |      * @param spender address The address which will spend the funds
 140 |     |      * @param amount uint256 The amount of tokens to be spent
 141 |     |      * @param data bytes Optional data to send along with the call
 142 |     |      * @return whether the call correctly returned the expected magic value
 143 |     |      */
 144 |     |     function _checkOnApprovalReceived(
 145 |     |         address spender,
 146 |     |         uint256 amount,
 147 |     |         bytes memory data
 148 |     |     ) internal virtual returns (bool) {
 149 |     |         if (!spender.isContract()) {
 150 |     |             revert("ERC1363: approve a non contract address");
 151 |     |         }
 152 |     | 
 153 |     |         try IERC1363Spender(spender).onApprovalReceived(_msgSender(), amount, data) returns (bytes4 retval) {
 154 |     |             return retval == IERC1363Spender.onApprovalReceived.selector;
 155 |     |         } catch (bytes memory reason) {
 156 |     |             if (reason.length == 0) {
 157 |     |                 revert("ERC1363: approve a non ERC1363Spender implementer");
 158 |     |             } else {
 159 |     |                 /// @solidity memory-safe-assembly
 160 |     |                 assembly {
 161 |     |                     revert(add(32, reason), mload(reason))
 162 |     |                 }
 163 |     |             }
 164 |     |         }
 165 |     |     }
 166 |     | }
 167 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/erc1363-payable-token/contracts/token/ERC1363/IERC1363.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import "../../../../openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
  6 |     | import "../../../../openzeppelin-contracts/contracts/utils/introspection/IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title IERC1363 Interface
 10 |     |  * @dev Interface of an ERC1363 compliant contract, as defined in the https://eips.ethereum.org/EIPS/eip-1363[EIP].
 11 |     |  */
 12 |     | interface IERC1363 is IERC20, IERC165 {
 13 |     |     /*
 14 |     |      * Note: the ERC-165 identifier for this interface is 0xb0202a11.
 15 |     |      * 0xb0202a11 ===
 16 |     |      *   bytes4(keccak256('transferAndCall(address,uint256)')) ^
 17 |     |      *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^
 18 |     |      *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^
 19 |     |      *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^
 20 |     |      *   bytes4(keccak256('approveAndCall(address,uint256)')) ^
 21 |     |      *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))
 22 |     |      */
 23 |     | 
 24 |     |     /**
 25 |     |      * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver.
 26 |     |      * @param to address The address which you want to transfer to
 27 |     |      * @param amount uint256 The amount of tokens to be transferred
 28 |     |      * @return true unless throwing
 29 |     |      */
 30 |     |     function transferAndCall(address to, uint256 amount) external returns (bool);
 31 |     | 
 32 |     |     /**
 33 |     |      * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver.
 34 |     |      * @param to address The address which you want to transfer to
 35 |     |      * @param amount uint256 The amount of tokens to be transferred
 36 |     |      * @param data bytes Additional data with no specified format, sent in call to `to`
 37 |     |      * @return true unless throwing
 38 |     |      */
 39 |     |     function transferAndCall(address to, uint256 amount, bytes calldata data) external returns (bool);
 40 |     | 
 41 |     |     /**
 42 |     |      * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver.
 43 |     |      * @param from address The address which you want to send tokens from
 44 |     |      * @param to address The address which you want to transfer to
 45 |     |      * @param amount uint256 The amount of tokens to be transferred
 46 |     |      * @return true unless throwing
 47 |     |      */
 48 |     |     function transferFromAndCall(address from, address to, uint256 amount) external returns (bool);
 49 |     | 
 50 |     |     /**
 51 |     |      * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver.
 52 |     |      * @param from address The address which you want to send tokens from
 53 |     |      * @param to address The address which you want to transfer to
 54 |     |      * @param amount uint256 The amount of tokens to be transferred
 55 |     |      * @param data bytes Additional data with no specified format, sent in call to `to`
 56 |     |      * @return true unless throwing
 57 |     |      */
 58 |     |     function transferFromAndCall(address from, address to, uint256 amount, bytes calldata data) external returns (bool);
 59 |     | 
 60 |     |     /**
 61 |     |      * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender
 62 |     |      * and then call `onApprovalReceived` on spender.
 63 |     |      * Beware that changing an allowance with this method brings the risk that someone may use both the old
 64 |     |      * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
 65 |     |      * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
 66 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 67 |     |      * @param spender address The address which will spend the funds
 68 |     |      * @param amount uint256 The amount of tokens to be spent
 69 |     |      */
 70 |     |     function approveAndCall(address spender, uint256 amount) external returns (bool);
 71 |     | 
 72 |     |     /**
 73 |     |      * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender
 74 |     |      * and then call `onApprovalReceived` on spender.
 75 |     |      * Beware that changing an allowance with this method brings the risk that someone may use both the old
 76 |     |      * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
 77 |     |      * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
 78 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 79 |     |      * @param spender address The address which will spend the funds
 80 |     |      * @param amount uint256 The amount of tokens to be spent
 81 |     |      * @param data bytes Additional data with no specified format, sent in call to `spender`
 82 |     |      */
 83 |     |     function approveAndCall(address spender, uint256 amount, bytes calldata data) external returns (bool);
 84 |     | }
 85 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/erc1363-payable-token/contracts/token/ERC1363/IERC1363Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title IERC1363Receiver interface
  7 |     |  * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`
  8 |     |  *  from ERC1363 token contracts.
  9 |     |  */
 10 |     | interface IERC1363Receiver {
 11 |     |     /*
 12 |     |      * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.
 13 |     |      * 0x88a7ca5c === bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))
 14 |     |      */
 15 |     | 
 16 |     |     /**
 17 |     |      * @notice Handle the receipt of ERC1363 tokens.
 18 |     |      * @dev Any ERC1363 smart contract calls this function on the recipient
 19 |     |      * after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the
 20 |     |      * transfer. Return of other than the magic value MUST result in the
 21 |     |      * transaction being reverted.
 22 |     |      * Note: the token contract address is always the message sender.
 23 |     |      * @param spender address The address which called `transferAndCall` or `transferFromAndCall` function
 24 |     |      * @param sender address The address which are token transferred from
 25 |     |      * @param amount uint256 The amount of tokens transferred
 26 |     |      * @param data bytes Additional data with no specified format
 27 |     |      * @return `bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))` unless throwing
 28 |     |      */
 29 |     |     function onTransferReceived(
 30 |     |         address spender,
 31 |     |         address sender,
 32 |     |         uint256 amount,
 33 |     |         bytes calldata data
 34 |     |     ) external returns (bytes4);
 35 |     | }
 36 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/erc1363-payable-token/contracts/token/ERC1363/IERC1363Spender.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title ERC1363Spender interface
  7 |     |  * @dev Interface for any contract that wants to support `approveAndCall`
  8 |     |  *  from ERC1363 token contracts.
  9 |     |  */
 10 |     | interface IERC1363Spender {
 11 |     |     /*
 12 |     |      * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.
 13 |     |      * 0x7b04a2d0 === bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))
 14 |     |      */
 15 |     | 
 16 |     |     /**
 17 |     |      * @notice Handle the approval of ERC1363 tokens.
 18 |     |      * @dev Any ERC1363 smart contract calls this function on the recipient
 19 |     |      * after an `approve`. This function MAY throw to revert and reject the
 20 |     |      * approval. Return of other than the magic value MUST result in the
 21 |     |      * transaction being reverted.
 22 |     |      * Note: the token contract address is always the message sender.
 23 |     |      * @param sender address The address which called `approveAndCall` function
 24 |     |      * @param amount uint256 The amount of tokens to be spent
 25 |     |      * @param data bytes Additional data with no specified format
 26 |     |      * @return `bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))` unless throwing
 27 |     |      */
 28 |     |     function onApprovalReceived(address sender, uint256 amount, bytes calldata data) external returns (bytes4);
 29 |     | }
 30 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 19 |     |  * to protect against it, check out our blog post
 20 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 21 |     |  */
 22 |     | abstract contract ReentrancyGuard {
 23 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 24 |     |     // word because each write operation emits an extra SLOAD to first read the
 25 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 26 |     |     // back. This is the compiler's defense against contract upgrades and
 27 |     |     // pointer aliasing, and it cannot be disabled.
 28 |     | 
 29 |     |     // The values being non-zero value makes deployment a bit more expensive,
 30 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 31 |     |     // amount. Since refunds are capped to a percentage of the total
 32 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 33 |     |     // increase the likelihood of the full refund coming into effect.
 34 | *   |     uint256 private constant _NOT_ENTERED = 1;
 35 | *r  |     uint256 private constant _ENTERED = 2;
 36 |     | 
 37 |     |     uint256 private _status;
 38 |     | 
 39 |     |     constructor() {
 40 |     |         _status = _NOT_ENTERED;
 41 |     |     }
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 45 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 46 |     |      * function is not supported. It is possible to prevent this from happening
 47 |     |      * by making the `nonReentrant` function external, and making it call a
 48 |     |      * `private` function that does the actual work.
 49 |     |      */
 50 |     |     modifier nonReentrant() {
 51 | *r  |         _nonReentrantBefore();
 52 |     |         _;
 53 | *   |         _nonReentrantAfter();
 54 |     |     }
 55 |     | 
 56 | *r  |     function _nonReentrantBefore() private {
 57 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
 58 | *r  |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
 59 |     | 
 60 |     |         // Any calls to nonReentrant after this point will fail
 61 | *r  |         _status = _ENTERED;
 62 |     |     }
 63 |     | 
 64 | *   |     function _nonReentrantAfter() private {
 65 |     |         // By storing the original value once again, a refund is triggered (see
 66 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 67 | *   |         _status = _NOT_ENTERED;
 68 |     |     }
 69 |     | }
 70 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  22 |     |  * instead returning `false` on failure. This behavior is nonetheless
  23 |     |  * conventional and does not conflict with the expectations of ERC20
  24 |     |  * applications.
  25 |     |  *
  26 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  27 |     |  * This allows applications to reconstruct the allowance for all accounts just
  28 |     |  * by listening to said events. Other implementations of the EIP may not emit
  29 |     |  * these events, as it isn't required by the specification.
  30 |     |  *
  31 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  32 |     |  * functions have been added to mitigate the well-known issues around setting
  33 |     |  * allowances. See {IERC20-approve}.
  34 |     |  */
  35 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  36 |     |     mapping(address => uint256) private _balances;
  37 |     | 
  38 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  39 |     | 
  40 |     |     uint256 private _totalSupply;
  41 |     | 
  42 |     |     string private _name;
  43 |     |     string private _symbol;
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Sets the values for {name} and {symbol}.
  47 |     |      *
  48 |     |      * The default value of {decimals} is 18. To select a different value for
  49 |     |      * {decimals} you should overload it.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 |     |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the value {ERC20} uses, unless this function is
  81 |     |      * overridden;
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 | *r  |     function totalSupply() public view virtual override returns (uint256) {
  95 | *r  |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *r  |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *r  |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 | *   |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 | *   |         address owner = _msgSender();
 115 | *   |         _transfer(owner, to, amount);
 116 | *   |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 |     |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 |     |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 |     |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 |     |         _approve(owner, spender, amount);
 139 |     |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 |     |     function transferFrom(
 159 |     |         address from,
 160 |     |         address to,
 161 |     |         uint256 amount
 162 |     |     ) public virtual override returns (bool) {
 163 |     |         address spender = _msgSender();
 164 |     |         _spendAllowance(from, spender, amount);
 165 |     |         _transfer(from, to, amount);
 166 |     |         return true;
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 171 |     |      *
 172 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 173 |     |      * problems described in {IERC20-approve}.
 174 |     |      *
 175 |     |      * Emits an {Approval} event indicating the updated allowance.
 176 |     |      *
 177 |     |      * Requirements:
 178 |     |      *
 179 |     |      * - `spender` cannot be the zero address.
 180 |     |      */
 181 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 182 |     |         address owner = _msgSender();
 183 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 184 |     |         return true;
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 189 |     |      *
 190 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 191 |     |      * problems described in {IERC20-approve}.
 192 |     |      *
 193 |     |      * Emits an {Approval} event indicating the updated allowance.
 194 |     |      *
 195 |     |      * Requirements:
 196 |     |      *
 197 |     |      * - `spender` cannot be the zero address.
 198 |     |      * - `spender` must have allowance for the caller of at least
 199 |     |      * `subtractedValue`.
 200 |     |      */
 201 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 202 |     |         address owner = _msgSender();
 203 |     |         uint256 currentAllowance = allowance(owner, spender);
 204 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 205 |     |         unchecked {
 206 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 207 |     |         }
 208 |     | 
 209 |     |         return true;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 214 |     |      *
 215 |     |      * This internal function is equivalent to {transfer}, and can be used to
 216 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 217 |     |      *
 218 |     |      * Emits a {Transfer} event.
 219 |     |      *
 220 |     |      * Requirements:
 221 |     |      *
 222 |     |      * - `from` cannot be the zero address.
 223 |     |      * - `to` cannot be the zero address.
 224 |     |      * - `from` must have a balance of at least `amount`.
 225 |     |      */
 226 | *   |     function _transfer(
 227 |     |         address from,
 228 |     |         address to,
 229 |     |         uint256 amount
 230 | *   |     ) internal virtual {
 231 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 232 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 233 |     | 
 234 | *   |         _beforeTokenTransfer(from, to, amount);
 235 |     | 
 236 | *   |         uint256 fromBalance = _balances[from];
 237 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 238 |     |         unchecked {
 239 | *   |             _balances[from] = fromBalance - amount;
 240 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 241 |     |             // decrementing then incrementing.
 242 | *   |             _balances[to] += amount;
 243 |     |         }
 244 |     | 
 245 | *   |         emit Transfer(from, to, amount);
 246 |     | 
 247 | *   |         _afterTokenTransfer(from, to, amount);
 248 |     |     }
 249 |     | 
 250 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 251 |     |      * the total supply.
 252 |     |      *
 253 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 254 |     |      *
 255 |     |      * Requirements:
 256 |     |      *
 257 |     |      * - `account` cannot be the zero address.
 258 |     |      */
 259 | *   |     function _mint(address account, uint256 amount) internal virtual {
 260 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 261 |     | 
 262 | *   |         _beforeTokenTransfer(address(0), account, amount);
 263 |     | 
 264 | *   |         _totalSupply += amount;
 265 |     |         unchecked {
 266 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 267 | *   |             _balances[account] += amount;
 268 |     |         }
 269 | *   |         emit Transfer(address(0), account, amount);
 270 |     | 
 271 | *   |         _afterTokenTransfer(address(0), account, amount);
 272 |     |     }
 273 |     | 
 274 |     |     /**
 275 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 276 |     |      * total supply.
 277 |     |      *
 278 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 279 |     |      *
 280 |     |      * Requirements:
 281 |     |      *
 282 |     |      * - `account` cannot be the zero address.
 283 |     |      * - `account` must have at least `amount` tokens.
 284 |     |      */
 285 | *   |     function _burn(address account, uint256 amount) internal virtual {
 286 | *   |         require(account != address(0), "ERC20: burn from the zero address");
 287 |     | 
 288 | *   |         _beforeTokenTransfer(account, address(0), amount);
 289 |     | 
 290 | *   |         uint256 accountBalance = _balances[account];
 291 | *   |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 292 |     |         unchecked {
 293 | *   |             _balances[account] = accountBalance - amount;
 294 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 295 | *   |             _totalSupply -= amount;
 296 |     |         }
 297 |     | 
 298 | *   |         emit Transfer(account, address(0), amount);
 299 |     | 
 300 | *   |         _afterTokenTransfer(account, address(0), amount);
 301 |     |     }
 302 |     | 
 303 |     |     /**
 304 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 305 |     |      *
 306 |     |      * This internal function is equivalent to `approve`, and can be used to
 307 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 308 |     |      *
 309 |     |      * Emits an {Approval} event.
 310 |     |      *
 311 |     |      * Requirements:
 312 |     |      *
 313 |     |      * - `owner` cannot be the zero address.
 314 |     |      * - `spender` cannot be the zero address.
 315 |     |      */
 316 |     |     function _approve(
 317 |     |         address owner,
 318 |     |         address spender,
 319 |     |         uint256 amount
 320 |     |     ) internal virtual {
 321 |     |         require(owner != address(0), "ERC20: approve from the zero address");
 322 |     |         require(spender != address(0), "ERC20: approve to the zero address");
 323 |     | 
 324 |     |         _allowances[owner][spender] = amount;
 325 |     |         emit Approval(owner, spender, amount);
 326 |     |     }
 327 |     | 
 328 |     |     /**
 329 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 330 |     |      *
 331 |     |      * Does not update the allowance amount in case of infinite allowance.
 332 |     |      * Revert if not enough allowance is available.
 333 |     |      *
 334 |     |      * Might emit an {Approval} event.
 335 |     |      */
 336 |     |     function _spendAllowance(
 337 |     |         address owner,
 338 |     |         address spender,
 339 |     |         uint256 amount
 340 |     |     ) internal virtual {
 341 |     |         uint256 currentAllowance = allowance(owner, spender);
 342 |     |         if (currentAllowance != type(uint256).max) {
 343 |     |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 344 |     |             unchecked {
 345 |     |                 _approve(owner, spender, currentAllowance - amount);
 346 |     |             }
 347 |     |         }
 348 |     |     }
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * will be transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 | *   |     function _beforeTokenTransfer(
 365 |     |         address from,
 366 |     |         address to,
 367 |     |         uint256 amount
 368 |     |     ) internal virtual {}
 369 |     | 
 370 |     |     /**
 371 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 372 |     |      * minting and burning.
 373 |     |      *
 374 |     |      * Calling conditions:
 375 |     |      *
 376 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 377 |     |      * has been transferred to `to`.
 378 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 379 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 380 |     |      * - `from` and `to` are never both zero.
 381 |     |      *
 382 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 383 |     |      */
 384 |     |     function _afterTokenTransfer(
 385 |     |         address from,
 386 |     |         address to,
 387 |     |         uint256 amount
 388 |     |     ) internal virtual {}
 389 |     | }
 390 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(
 78 |     |         address from,
 79 |     |         address to,
 80 |     |         uint256 amount
 81 |     |     ) external returns (bool);
 82 |     | }
 83 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      * ====
  26 |     |      *
  27 |     |      * [IMPORTANT]
  28 |     |      * ====
  29 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  30 |     |      *
  31 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  32 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  33 |     |      * constructor.
  34 |     |      * ====
  35 |     |      */
  36 |     |     function isContract(address account) internal view returns (bool) {
  37 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  38 |     |         // for contracts in construction, since the code is only stored at the end
  39 |     |         // of the constructor execution.
  40 |     | 
  41 |     |         return account.code.length > 0;
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  46 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  47 |     |      *
  48 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  49 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  50 |     |      * imposed by `transfer`, making them unable to receive funds via
  51 |     |      * `transfer`. {sendValue} removes this limitation.
  52 |     |      *
  53 |     |      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  54 |     |      *
  55 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  56 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  57 |     |      * {ReentrancyGuard} or the
  58 |     |      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  59 |     |      */
  60 | *   |     function sendValue(address payable recipient, uint256 amount) internal {
  61 | *   |         require(address(this).balance >= amount, "Address: insufficient balance");
  62 |     | 
  63 | *   |         (bool success, ) = recipient.call{value: amount}("");
  64 | *   |         require(success, "Address: unable to send value, recipient may have reverted");
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  69 |     |      * plain `call` is an unsafe replacement for a function call: use this
  70 |     |      * function instead.
  71 |     |      *
  72 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  73 |     |      * function (like regular Solidity function calls).
  74 |     |      *
  75 |     |      * Returns the raw returned data. To convert to the expected return value,
  76 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  77 |     |      *
  78 |     |      * Requirements:
  79 |     |      *
  80 |     |      * - `target` must be a contract.
  81 |     |      * - calling `target` with `data` must not revert.
  82 |     |      *
  83 |     |      * _Available since v3.1._
  84 |     |      */
  85 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  86 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  91 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  92 |     |      *
  93 |     |      * _Available since v3.1._
  94 |     |      */
  95 |     |     function functionCall(
  96 |     |         address target,
  97 |     |         bytes memory data,
  98 |     |         string memory errorMessage
  99 |     |     ) internal returns (bytes memory) {
 100 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 105 |     |      * but also transferring `value` wei to `target`.
 106 |     |      *
 107 |     |      * Requirements:
 108 |     |      *
 109 |     |      * - the calling contract must have an ETH balance of at least `value`.
 110 |     |      * - the called Solidity function must be `payable`.
 111 |     |      *
 112 |     |      * _Available since v3.1._
 113 |     |      */
 114 |     |     function functionCallWithValue(
 115 |     |         address target,
 116 |     |         bytes memory data,
 117 |     |         uint256 value
 118 |     |     ) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 |     |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 |     |     ) internal view returns (bytes memory) {
 201 |     |         if (success) {
 202 |     |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 |     |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  *
 20 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 21 |     |  */
 22 |     | abstract contract ERC165 is IERC165 {
 23 |     |     /**
 24 |     |      * @dev See {IERC165-supportsInterface}.
 25 |     |      */
 26 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 27 |     |         return interfaceId == type(IERC165).interfaceId;
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/src/BondingToken.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.15;
   3 |     | 
   4 |     | import "../lib/erc1363-payable-token/contracts/token/ERC1363/ERC1363.sol";
   5 |     | import "../lib/erc1363-payable-token/contracts/token/ERC1363/IERC1363Receiver.sol";
   6 |     | import "../lib/openzeppelin-contracts/contracts/utils/Address.sol";
   7 |     | import "../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol";
   8 |     | import "./IBondingToken.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title BondingToken
  12 |     |  * @dev A token contract that implements a bonding curve for buying and selling tokens using Ether.
  13 |     |  * The contract uses ERC1363 to accept and transfer tokens, and implements the IBondingToken interface for buying and selling tokens.
  14 |     |  * The contract also implements the IERC1363Receiver interface to receive tokens that are sent to the contract.
  15 | *r  |  */
  16 |     | contract BondingToken is
  17 |     |     ERC1363,
  18 |     |     IERC1363Receiver,
  19 |     |     IBondingToken,
  20 |     |     ReentrancyGuard
  21 |     | {
  22 | *r  |     uint256 constant MULTIPLIER = 10 ** 6; // 1_000_000
  23 | *   |     uint256 public constant MAX_BUY_AMOUNT_PER_TX = 1_000_000_000;
  24 | *   |     uint256 public constant MAX_SUPPLY_THRESHOLD = 1_000_000_000_000;
  25 |     | 
  26 |     |     /**
  27 |     |      * @dev Throws if the caller is not the token contract.
  28 |     |      */
  29 |     |     modifier onlyAllowedToken() {
  30 |     |         require(msg.sender == address(this), "Only allowed token");
  31 |     |         _;
  32 |     |     }
  33 |     | 
  34 |     |     /**
  35 |     |      * @dev Initializes the contract with the given name and symbol.
  36 |     |      * @param _name The name of the token.
  37 |     |      * @param _symbol The symbol of the token.
  38 |     |      */
  39 |     |     constructor(
  40 |     |         string memory _name,
  41 |     |         string memory _symbol
  42 |     |     ) ERC20(_name, _symbol) {}
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Checks if a contract implements the IBondingToken interface.
  46 |     |      * @param interfaceId The interface ID being checked.
  47 |     |      * @return A boolean indicating if the contract implements the IBondingToken interface.
  48 |     |      */
  49 |     |     function supportsInterface(
  50 |     |         bytes4 interfaceId
  51 |     |     ) public view override(ERC1363) returns (bool) {
  52 |     |         return
  53 |     |             interfaceId == type(IBondingToken).interfaceId ||
  54 |     |             super.supportsInterface(interfaceId);
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev Allows a user to buy tokens by sending Ether to the contract.
  59 |     |      * @param amount The amount of tokens to buy.
  60 |     |      */
  61 | *r  |     function buy(uint256 amount) public payable nonReentrant {
  62 | *r  |         require(msg.value > 0, "Insufficient funds");
  63 | *r  |         require(amount > 0, "Amount is zero");
  64 | *   |         require(amount <= MAX_BUY_AMOUNT_PER_TX, "Amount is too high");
  65 |     | 
  66 | *   |         _buy(msg.sender, amount);
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Internal function to buy tokens.
  71 |     |      * @param account The address of the account to receive the tokens.
  72 |     |      * @param amount The amount of tokens to buy.
  73 |     |      */
  74 | *   |     function _buy(address account, uint256 amount) private {
  75 | *   |         uint256 cost = calculatePriceForTokens(amount);
  76 | *   |         require(msg.value >= cost, "Insufficient funds");
  77 | *   |         _mint(account, amount);
  78 | *   |         require(
  79 | *   |             totalSupply() <= MAX_SUPPLY_THRESHOLD,
  80 |     |             "Max supply threshold reached"
  81 |     |         );
  82 | *   |         if (msg.value > cost) {
  83 | *   |             Address.sendValue(payable(account), msg.value - cost);
  84 |     |         }
  85 |     | 
  86 | *   |         emit Buy(account, amount);
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Allows a user to sell tokens back to the contract in exchange for Ether.
  91 |     |      * @param amount The amount of tokens to sell.
  92 |     |      */
  93 | *   |     function sell(uint256 amount) external nonReentrant {
  94 | *   |         require(balanceOf(msg.sender) >= amount, "Insufficient amount");
  95 |     | 
  96 | *   |         bool success = transfer(address(this), amount);
  97 | *   |         if (!success) {
  98 |     |             revert("Transfer failed");
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Internal function to sell tokens.
 104 |     |      * @param account The address of the account to receive the Ether.
 105 |     |      * @param amount The amount of tokens to sell.
 106 |     |      */
 107 | *   |     function _sell(address account, uint256 amount) private {
 108 | *   |         _burn(address(this), amount);
 109 | *   |         uint256 payout = calculatePriceForTokens(amount);
 110 | *   |         Address.sendValue(payable(account), payout);
 111 |     | 
 112 | *   |         emit Sell(account, amount);
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev Overrides the ERC20 _afterTokenTransfer function to sell tokens when
 117 |     |      * they are transferred to the contract.
 118 |     |      * @param from The address of the account sending the tokens.
 119 |     |      * @param to The address of the account receiving the tokens.
 120 |     |      * @param amount The amount of tokens being transferred.
 121 |     |      */
 122 | *   |     function _afterTokenTransfer(
 123 |     |         address from,
 124 |     |         address to,
 125 |     |         uint256 amount
 126 |     |     ) internal override {
 127 | *   |         if (from != address(0) && to == address(this)) {
 128 | *   |             _sell(from, amount);
 129 |     |         }
 130 |     |     }
 131 |     | 
 132 |     |     /**
 133 |     |      * @dev Calculates the cost of buying a given amount of tokens.
 134 |     |      * @param amount The amount of tokens to calculate the cost for.
 135 |     |      * @return The cost of buying the given amount of tokens.
 136 |     |      */
 137 | *   |     function calculatePriceForTokens(
 138 |     |         uint256 amount
 139 | *   |     ) public view returns (uint256) {
 140 | *   |         return calculatePriceForTokens(amount, totalSupply());
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @dev Calculates the amount of tokens that can be bought with a given amount of Ether.
 145 |     |      * @param amount The amount of Ether to calculate the token amount for.
 146 |     |      * @return The amount of tokens that can be bought with the given amount of Ether.
 147 |     |      */
 148 | *r  |     function calculateTokensForPrice(
 149 |     |         uint256 amount
 150 | *r  |     ) public view returns (uint256) {
 151 | *r  |         return calculateTokensForPrice(amount, totalSupply());
 152 |     |     }
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Called by ERC1363 to indicate that tokens have been transferred to the contract.
 156 |     |      */
 157 |     |     function onTransferReceived(
 158 |     |         address,
 159 |     |         address,
 160 |     |         uint256,
 161 |     |         bytes calldata
 162 |     |     ) external view override onlyAllowedToken returns (bytes4) {
 163 |     |         return IERC1363Receiver.onTransferReceived.selector;
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @dev Allows the contract to receive Ether by calling the buy function with the amount of tokens
 168 |     |      * that can be bought with the received Ether.
 169 |     |      */
 170 | *   |     fallback(
 171 |     |         bytes calldata _input
 172 | *r  |     ) external payable returns (bytes memory _output) {
 173 | *r  |         require(msg.value > 0, "Insufficient funds");
 174 | *r  |         uint256 amount = calculateTokensForPrice(msg.value);
 175 | *r  |         uint256 decoded = abi.decode(_input, (uint256));
 176 | *r  |         require(amount >= decoded, "Slippage is too high");
 177 | *r  |         buy(amount);
 178 | *   |         return abi.encode(amount);
 179 |     |     }
 180 |     | 
 181 |     |     receive() external payable {
 182 |     |         revert("Not supported");
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @dev The `calculatePriceForTokens` function takes an amount of tokens and the current token supply
 187 |     |      * as input and returns the cost of purchasing that amount of tokens in Ether.
 188 |     |      *
 189 |     |      * priceForTokens = poolBalance(tokenSupply + amount) - poolBalance(tokenSupply)
 190 |     |      * poolBalance = ((tokenSupply + 1) ^ 3) / 3
 191 |     |      */
 192 | *r  |     function calculatePriceForTokens(
 193 |     |         uint256 amount,
 194 |     |         uint256 supply
 195 | *r  |     ) public pure returns (uint256) {
 196 | *r  |         return
 197 | *r  |             ((((supply + amount + 1) ** 3 - (supply + 1) ** 3) * MULTIPLIER) /
 198 | *r  |                 3) - (amount / 3);
 199 |     |     }
 200 |     | 
 201 |     |     /**
 202 |     |      * @dev The `calculateTokensForPrice` function takes an amount of Ether and the current token supply
 203 |     |      * as input and returns the number of tokens that can be purchased with that amount of Ether.
 204 |     |      */
 205 | *r  |     function calculateTokensForPrice(
 206 |     |         uint256 amount,
 207 |     |         uint256 supply
 208 | *r  |     ) public pure returns (uint256) {
 209 | *r  |         uint256 root = cubeRoot((amount / MULTIPLIER) * 3 + (supply + 1) ** 3);
 210 | *r  |         require(root >= supply + 1, "Amount is too low");
 211 | *r  |         return root - supply - 1;
 212 |     |     }
 213 |     | 
 214 |     |     /**
 215 |     |      * @dev The `cubeRoot` function calculates the cube root of a non-negative integer using the nthRoot
 216 |     |      * function implemented using the binary search algorithm.
 217 |     |      */
 218 | *r  |     function cubeRoot(uint256 n) internal pure returns (uint256) {
 219 | *r  |         return nthRoot(n, 3);
 220 |     |     }
 221 |     | 
 222 |     |     /**
 223 |     |      * @dev  The nthRoot function calculates the integer n-th root of a non-negative integer x
 224 |     |      * using the binary search algorithm. The function begins by initializing the search
 225 |     |      * range to [0, x]. At each iteration of the loop, the function calculates the midpoint
 226 |     |      * mid of the search range and raises it to the n-th power. If mid^n is equal to x,
 227 |     |      * the function returns mid as the result. If mid^n is less than x, the search range is
 228 |     |      * updated to the right half of the previous range. If mid^n is greater than x, the search
 229 |     |      * range is updated to the left half of the previous range. The loop terminates when
 230 |     |      * the search range is reduced to a single integer value, which is then returned as the
 231 |     |      * largest integer y such that y^n <= x.
 232 |     |      *
 233 |     |      * Note: The binary search algorithm implemented in the nthRoot function has a time complexity
 234 |     |      * of O(log x), which makes it more efficient than Newton's method for large values of x.
 235 |     |      * However, the binary search algorithm can only calculate the integer n-th root of a
 236 |     |      * non-negative integer x. It cannot be used to calculate the real-valued n-th root of a
 237 |     |      * non-negative real number x, which is a limitation of the algorithm.
 238 |     |      */
 239 | *r  |     function nthRoot(uint256 x, uint256 n) internal pure returns (uint256) {
 240 | *r  |         require(n > 0, "Root must be positive");
 241 |     | 
 242 | *r  |         if (x == 0) {
 243 |     |             return 0;
 244 |     |         }
 245 |     | 
 246 | *r  |         uint256 left = 0;
 247 | *r  |         uint256 right = x;
 248 |     | 
 249 | *r  |         while (left < right) {
 250 | *r  |             uint256 mid = (left + right) / 2;
 251 | *r  |             uint256 midToNthPower = mid ** n;
 252 |     | 
 253 | *r  |             if (midToNthPower == x) {
 254 | r   |                 return mid;
 255 | *r  |             } else if (midToNthPower < x) {
 256 | *r  |                 left = mid + 1;
 257 |     |             } else {
 258 | *r  |                 right = mid;
 259 |     |             }
 260 |     |         }
 261 |     | 
 262 | *r  |         return left - 1;
 263 |     |     }
 264 |     | }
 265 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/src/IBondingToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.15;
  3 |     | 
  4 |     | /**
  5 |     |  * @title IBondingToken
  6 |     |  * @dev Interface for a bonding token contract that allows buying and selling of tokens at a calculated price.
  7 |     |  */
  8 |     | interface IBondingToken {
  9 |     |     /**
 10 |     |      * @dev Emitted when tokens are bought.
 11 |     |      * @param account The account that bought the tokens.
 12 |     |      * @param amount The amount of tokens bought.
 13 |     |      */
 14 |     |     event Buy(address indexed account, uint256 amount);
 15 |     |     
 16 |     |     /**
 17 |     |      * @dev Emitted when tokens are sold.
 18 |     |      * @param account The account that sold the tokens.
 19 |     |      * @param amount The amount of tokens sold.
 20 |     |      */
 21 |     |     event Sell(address indexed account, uint256 amount);
 22 |     | 
 23 |     |     /**
 24 |     |      * @dev Buy tokens with ETH at a calculated price.
 25 |     |      * @param amount The amount of tokens to buy.
 26 |     |      */
 27 |     |     function buy(uint256 amount) external payable;
 28 |     |     
 29 |     |     /**
 30 |     |      * @dev Sell tokens at a calculated price and receive ETH.
 31 |     |      * @param amount The amount of tokens to sell.
 32 |     |      */
 33 |     |     function sell(uint256 amount) external;
 34 |     |     
 35 |     |     /**
 36 |     |      * @dev Calculate the price for a given amount of tokens.
 37 |     |      * @param amount The amount of tokens to calculate the price for.
 38 |     |      * @return A The calculated price for the given amount of tokens.
 39 |     |      */
 40 |     |     function calculatePriceForTokens(uint256 amount) external view returns (uint256);
 41 |     |     
 42 |     |     /**
 43 |     |      * @dev Calculate the amount of tokens for a given price.
 44 |     |      * @param amount The price to calculate the amount of tokens for.
 45 |     |      * @return A The calculated amount of tokens for the given price.
 46 |     |      */
 47 |     |     function calculateTokensForPrice(uint256 amount) external view returns (uint256);
 48 |     | }
 49 |     | 

/Users/vladimirtrifonov/src/playground/solidity/rare-skills/advanced-solidity-bootcamp/fuzzing-with-echidna/bonding-token/test/TestBondingToken.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.15;
   3 |     | 
   4 |     | import "../src/BondingToken.sol";
   5 |     | 
   6 |     | /// @dev Run the template with
   7 |     | ///      ```
   8 |     | ///      solc-select use 0.8.19
   9 |     | ///      echidna ./test/TestBondingToken.sol --contract TestBondingToken --config ./config.yaml
  10 | *r  | ///      ```
  11 |     | contract TestBondingToken {
  12 |     |     BondingToken bondingToken;
  13 |     | 
  14 |     |     event Balance(uint256 amount, uint256 price, uint256 balance);
  15 |     | 
  16 |     |     constructor() payable {
  17 |     |         bondingToken = new BondingToken("TestBondingToken", "TBT");
  18 |     |     }
  19 |     | 
  20 | *r  |     function test_buy(uint256 amount) public {
  21 | *   |         amount = amount > 0 ? amount : bondingToken.MAX_BUY_AMOUNT_PER_TX();
  22 | *   |         amount = 1 + (amount % bondingToken.MAX_BUY_AMOUNT_PER_TX());
  23 | *   |         uint256 balance = bondingToken.balanceOf(address(this));
  24 | *   |         uint256 cost = bondingToken.calculatePriceForTokens(amount);
  25 | *   |         bondingToken.buy{value: cost}(amount);
  26 |     | 
  27 | *   |         assert(bondingToken.balanceOf(address(this)) == balance + amount);
  28 |     |     }
  29 |     | 
  30 | *r  |     function test_supply(uint256 amount, bool isBuy) public {
  31 | *   |         amount = amount > 0 ? amount : bondingToken.MAX_BUY_AMOUNT_PER_TX();
  32 | *   |         if (isBuy) {
  33 | *   |             amount = 1 + (amount % bondingToken.MAX_BUY_AMOUNT_PER_TX());
  34 | *   |             uint256 cost = bondingToken.calculatePriceForTokens(amount);
  35 | *   |             bondingToken.buy{value: cost}(amount);
  36 | *   |         } else {
  37 | *   |             uint256 balance = bondingToken.balanceOf(address(this));
  38 | *   |             if (balance > 0) {
  39 | *   |                 amount = 1 + (amount % balance);
  40 | *   |                 amount = amount > 0 ? amount : balance;
  41 | *   |                 try bondingToken.sell(amount) {
  42 | *   |                     assert(true);
  43 |     |                 } catch {
  44 |     |                     emit Balance(
  45 |     |                         amount,
  46 |     |                         bondingToken.calculatePriceForTokens(amount),
  47 |     |                         address(bondingToken).balance
  48 |     |                     );
  49 |     |                     assert(false);
  50 |     |                 }
  51 |     |             }
  52 |     |         }
  53 |     | 
  54 | *   |         assert(
  55 | *   |             bondingToken.totalSupply() <= bondingToken.MAX_SUPPLY_THRESHOLD()
  56 |     |         );
  57 |     |     }
  58 |     | 
  59 | *r  |     function test_balance(uint256 amount) public {
  60 | *   |         amount = amount > 0 ? amount : bondingToken.MAX_BUY_AMOUNT_PER_TX();
  61 | *   |         uint256 initialBalance = bondingToken.balanceOf(address(this));
  62 | *   |         uint256 initialEth = address(this).balance;
  63 | *   |         amount = 1 + (amount % bondingToken.MAX_BUY_AMOUNT_PER_TX());
  64 | *   |         uint256 cost = bondingToken.calculatePriceForTokens(amount);
  65 | *   |         bondingToken.buy{value: cost}(amount);
  66 | *   |         try bondingToken.sell(amount) {
  67 | *   |             assert(true);
  68 |     |         } catch {
  69 |     |             assert(false);
  70 |     |         }
  71 |     | 
  72 | *   |         assert(bondingToken.balanceOf(address(this)) == initialBalance);
  73 | *   |         assert(initialEth == address(this).balance);
  74 |     |     }
  75 |     | 
  76 | *r  |     function test_payout(uint256 amount) public {
  77 | *r  |         uint256 initSupply = bondingToken.totalSupply();
  78 | *r  |         uint256 balance = bondingToken.balanceOf(address(this));
  79 | *r  |         uint256 ethBalance = address(this).balance;
  80 | *r  |         uint256 tokenEthBalance = address(bondingToken).balance;
  81 | *r  |         amount = 1 + (amount % ethBalance);
  82 | *r  |         if (amount == 0) {
  83 |     |             amount = 10 ether;
  84 |     |         }
  85 | *r  |         (bool success, ) = address(bondingToken).call{value: amount}(
  86 | *r  |             abi.encode(bondingToken.calculateTokensForPrice(amount))
  87 |     |         );
  88 | *r  |         uint256 bought = bondingToken.balanceOf(address(this)) - balance;
  89 | *r  |         uint256 cost = bondingToken.calculatePriceForTokens(bought, initSupply);
  90 |     | 
  91 | *r  |         assert(success);
  92 | *   |         assert(address(this).balance == ethBalance - cost);
  93 | *   |         assert(address(bondingToken).balance == tokenEthBalance + cost);
  94 |     |     }
  95 |     | 
  96 | *r  |     function test_transfer(uint256 amount) public {
  97 | *r  |         uint256 balance = bondingToken.balanceOf(address(this));
  98 | *r  |         amount = 1 + (amount % balance);
  99 | *   |         uint256 ethBalance = address(this).balance;
 100 | *   |         require(amount > 0, "balance is zero");
 101 |     | 
 102 | *   |         bondingToken.transfer(address(bondingToken), amount);
 103 | *   |         uint256 payout = bondingToken.calculatePriceForTokens(amount);
 104 |     | 
 105 | *   |         assert(bondingToken.balanceOf(address(this)) == balance - amount);
 106 | *   |         assert(address(this).balance == ethBalance + payout);
 107 |     |     }
 108 |     | 
 109 |     |     receive() external payable {}
 110 |     | }
 111 |     | 

